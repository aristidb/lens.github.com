{"body":"Lens: Lenses, Folds, and Traversals\r\n===================================\r\n\r\nThis package provides families of [lenses](https://github.com/ekmett/lens/blob/master/src/Control/Lens/Type.hs), [isomorphisms](https://github.com/ekmett/lens/blob/master/src/Control/Lens/Iso.hs), [folds](https://github.com/ekmett/lens/blob/master/src/Control/Lens/Fold.hs), [traversals](https://github.com/ekmett/lens/blob/master/src/Control/Lens/Traversal.hs), [getters](https://github.com/ekmett/lens/blob/master/src/Control/Lens/Getter.hs) and [setters](https://github.com/ekmett/lens/blob/master/src/Control/Lens/Setter.hs).\r\n\r\nThe [FAQ](https://github.com/ekmett/lens/wiki/FAQ), which provides links to a large number of different resources for learning about lenses and an overview of the [derivation](https://github.com/ekmett/lens/wiki/Derivation) of these types can be found on the [Lens Wiki](https://github.com/ekmett/lens/wiki) along with a brief [overview](https://github.com/ekmett/lens/wiki/Overview) and some [examples](https://github.com/ekmett/lens/wiki/Examples).\r\n\r\nDocumentation is available through [github](http://ekmett.github.com/lens/frames.html) (for HEAD) or [hackage](http://hackage.haskell.org/package/lens) for the current and preceding releases.\r\n\r\nExamples\r\n--------\r\n\r\n(See [`wiki/Examples`](https://github.com/ekmett/lens/wiki/Examples))\r\n\r\nFirst, import `Control.Lens`.\r\n\r\n```haskell\r\nghci> import Control.Lens\r\n```\r\n\r\nNow, you can read from lenses\r\n\r\n```haskell\r\nghci> (\"hello\",\"world\")^._2\r\n\"world\"\r\n```\r\n\r\nand you can write to lenses.\r\n\r\n```haskell\r\nghci> set _2 42 (\"hello\",\"world\")\r\n(\"hello\",42)\r\n```\r\n\r\nComposing lenses for reading (or writing) goes in the order an imperative programmer would expect, and just uses `(.)` from the `Prelude`.\r\n\r\n```haskell\r\nghci> (\"hello\",(\"world\",\"!!!\"))^._2._1\r\n\"world\"\r\n```\r\n\r\n```haskell\r\nghci> set (_2._1) 42 (\"hello\",(\"world\",\"!!!\"))\r\n(\"hello\",(42,\"!!!\"))\r\n```\r\n\r\nYou can make a `Getter` out of a pure functions with `to`.\r\n\r\n```haskell\r\nghci> \"hello\"^.to length\r\n5\r\n```\r\n\r\nYou can easily compose a `Getter` with a `Lens` just using `(.)`. No explicit coercion is necessary.\r\n\r\n```haskell\r\nghci> (\"hello\",(\"world\",\"!!!\"))^._2._2.to length\r\n3\r\n```\r\n\r\nAs we saw above, you can write to lenses and these writes can change the type of the container. `(.~)` is an infix alias for `set`.\r\n\r\n```haskell\r\nghci> _1 .~ \"hello\" $ ((),\"world\")\r\n(\"hello\",\"world)\r\n```\r\n\r\nConversely `view`, can be used as a prefix alias for `(^.)`.\r\n\r\n```haskell\r\nghci> view _2 (10,20)\r\n20\r\n```\r\n\r\nThere are a large number of other lens variants provided by the library, in particular a `Traversal` generalizes `traverse` from `Data.Traversable`.\r\n\r\nWe'll come back to those later, but continuing with just lenses:\r\n\r\nYou can let the library automatically derive lenses for fields of your data type\r\n\r\n```haskell\r\ndata Foo a = Foo { _bar :: Int, _baz :: Int, _quux :: a }\r\nmakeLenses ''Foo\r\n```\r\n\r\nThis will automatically generate the following lenses:\r\n\r\n```haskell\r\nbar, baz :: Simple Lens (Foo a) Int\r\nquux :: Lens (Foo a) (Foo b) a b\r\n```\r\n\r\nA `Lens` takes 4 parameters because it can change the types of the whole when you change the type of the part.\r\n\r\nOften you won't need this flexibility, a `Simple Lens` takes 2 parameters, and can be used directly as a `Lens`.\r\n\r\nYou can also write to setters that target multiple parts of a structure, or their composition with other\r\nlenses or setters. The canonical example of a setter is 'mapped':\r\n\r\n```haskell\r\nmapped :: Functor f => Setter (f a) (f b) a b\r\n```\r\n\r\n`over` is then analogous to `fmap`, but parameterized on the Setter.\r\n\r\n```haskell\r\nghci> fmap succ [1,2,3]\r\n[2,3,4]\r\nghci> over mapped succ [1,2,3]\r\n[2,3,4]\r\n```\r\n\r\nThe benefit is that you can use any `Lens` as a `Setter`, and the composition of setters with other setters or lenses using `(.)` yields\r\na `Setter`.\r\n\r\n```haskell\r\nghci> over (mapped._2) succ [(1,2),(3,4)]\r\n[(1,3),(3,5)]\r\n```\r\n\r\n`(%~)` is an infix alias for 'over', and the precedence lets you avoid swimming in parentheses:\r\n\r\n```haskell\r\nghci> _1.mapped._2.mapped %~ succ $ ([(42, \"hello\")],\"world\")\r\n([(42, \"ifmmp\")],\"world\")\r\n```\r\n\r\nThere are a number of combinators that resemble the `+=`, `*=`, etc. operators from C/C++ for working with the monad transformers.\r\n\r\nThere are `+~`, `*~`, etc. analogues to those combinators that work functionally, returning the modified version of the structure.\r\n\r\n```haskell\r\nghci> both *~ 2 $ (1,2)\r\n(2,4)\r\n```\r\n\r\nThere are combinators for manipulating the current state in a state monad as well\r\n\r\n```haskell\r\nfresh :: MonadState Int m => m Int\r\nfresh = id <+= 1\r\n```\r\n\r\nAnything you know how to do with a `Foldable` container, you can do with a `Fold`\r\n\r\n```haskell\r\nghci> :m + Data.Char Data.Text.Lens\r\nghci> allOf (folded.text) isLower [\"hello\"^.packed, \"goodbye\"^.packed]\r\nTrue\r\n```\r\n\r\nYou can also use this for generic programming. Combinators are included that are based on Neil Mitchell's `uniplate`, but which\r\nhave been generalized to work on or as lenses, folds, and traversals.\r\n\r\n```haskell\r\nghci> :m + Data.Data.Lens\r\nghci> anyOf biplate (==\"world\") (\"hello\",(),[(2::Int,\"world\")])\r\nTrue\r\n```\r\n\r\nAs alluded to above, anything you know how to do with a `Traversable` you can do with a `Traversal`.\r\n\r\n```haskell\r\nghci> mapMOf (traverse._2) (\\xs -> length xs <$ putStrLn xs) [(42,\"hello\"),(56,\"world\")]\r\n\"hello\"\r\n\"world\"\r\n[(42,5),(56,5)]\r\n```\r\n\r\nMoreover, many of the lenses supplied are actually isomorphisms, that means you can use them directly as a lens or getter:\r\n\r\n```haskell\r\nghci> let hello = \"hello\"^.packed\r\n\"hello\"\r\nghci> :t hello\r\nhello :: Text\r\n```\r\n\r\nbut you can also flip them around and use them as a lens the other way with `from`!\r\n\r\n```haskell\r\nghci> hello^.from packed.to length\r\n5\r\n```\r\n\r\nYou can automatically derive isomorphisms for your own newtypes with `makeIso`. e.g.\r\n\r\n```haskell\r\nnewtype Neither a b = Neither { _nor :: Either a b } deriving (Show)\r\nmakeIso ''Neither\r\n```\r\n\r\nwill automatically derive\r\n\r\n```haskell\r\nneither :: Iso (Neither a b) (Neither c d) (Either a b) (Either c d)\r\nnor :: Iso (Either a b) (Either c d) (Neither a b) (Neither c d)\r\n```\r\n\r\nsuch that\r\n\r\n```haskell\r\nfrom neither = nor\r\nfrom nor = neither\r\nneither.nor = id\r\nnor.neither = id\r\n```\r\n\r\nThere is also a fully operational, but simple game of [Pong](https://github.com/ekmett/lens/blob/master/examples/Pong.hs) in the [examples/](https://github.com/ekmett/lens/blob/master/examples/) folder.\r\n\r\nThere are also hundreds of examples distributed throughout the [documentation](https://ekmett.github.com/lens/).","google":"UA-36903038-1","name":"The Lens Project","tagline":"Lenses, Folds, and Traversals","note":"Don't delete this file! It's used internally to help with page regeneration."}